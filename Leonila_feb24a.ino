#include "arduino_secrets.h"

/* 
  Sketch generated by the Arduino IoT Cloud Thing "Untitled 2"
  https://create.arduino.cc/cloud/things/610251ed-5728-4cf7-a71e-0ddaf3f93f6d 

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  float dissolved;
  float phValue;
  float stepperVariable1;
  float stepperVariable2;
  float stepperVariable3;
  float stepperVariable4;
  float stepperVariable5;
  float stepperVariable6;
  float tempCelsius;
  float tempFahrenheit;
  bool messengerUpdates;
  bool servoPushButton;
  bool wifiLED;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

#include "thingProperties.h"
//temp sensor includes
#include <OneWire.h>
#include <DallasTemperature.h>
//ph sensor includes

//DO sensor includes
#include <Arduino.h>
//email includes and define
#include "ESP32_MailClient.h"
//feeder
#include <ESP32Servo.h>
//relay
const int RELAY_PIN = 16;
//email sender
#define emailSenderAccount    "fishpondnotif.456@gmail.com"
#define emailSenderPassword   "xxgpvisyyzncvodv"
#define smtpServer            "smtp.gmail.com"
#define smtpServerPort        465
#define emailSubject          "[ALERT] ESP32 Temperature"
//email receiver
String inputMessage = "fishpondreceiver.456@gmail.com";

// The Email Sending data object contains config and data to send
SMTPData smtpData;
// Flag variable to keep track if email notification was sent or not
bool emailSent = false;
bool emailSent1 = false;
bool emailSent2 = false;
bool do_aerator;
bool temp_aerator;

//temp sensor define
const int SENSOR_PIN = 25; // Arduino pin connected to DS18B20 sensor's DQ pin
OneWire oneWire(SENSOR_PIN);         // setup a oneWire instance
DallasTemperature tempSensor(&oneWire); // pass oneWire to DallasTemperature library
//feeder
Servo myservo; 
int pos = 0; 

//ph sensor define
float calibration_value = 21.34 + 1.2;
int phval = 0;
unsigned long int avgval;
int buffer_arr[10],temp;
 
//Wifi Credentials for Wifi status and LED indicator
const char* ssid = SECRET_SSID;
const char* password = SECRET_OPTIONAL_PASS;

//do sensor defines
#define DO_PIN 32
#define VREF 5000    //VREF (mv)
#define ADC_RES 1024 //ADC Resolution

//Single-point calibration Mode=0
//Two-point calibration Mode=1
#define TWO_POINT_CALIBRATION 0

#define READ_TEMP (25) //Current water temperature ℃, Or temperature sensor function
//Single point calibration needs to be filled CAL1_V and CAL1_T
#define CAL1_V (9600) //mv
#define CAL1_T (25)   //℃
//Two-point calibration needs to be filled CAL2_V and CAL2_T
//CAL1 High temperature point, CAL2 Low temperature point
#define CAL2_V (1300) //mv
#define CAL2_T (15)   //℃

//LED define
#define LED 19


const uint16_t DO_Table[41] = {
    14460, 14220, 13820, 13440, 13090, 12740, 12420, 12110, 11810, 11530,
    11260, 11010, 10770, 10530, 10300, 10080, 9860, 9660, 9460, 9270,
    9080, 8900, 8730, 8570, 8410, 8250, 8110, 7960, 7820, 7690,
    7560, 7430, 7300, 7180, 7070, 6950, 6840, 6730, 6630, 6530, 6410};

uint8_t Temperaturet;
uint16_t ADC_Raw;
uint16_t ADC_Voltage;
uint16_t DO;

int16_t readDO(uint32_t voltage_mv, uint8_t temperature_c)
{
#if TWO_POINT_CALIBRATION == 0
  uint16_t V_saturation = (uint32_t)CAL1_V + (uint32_t)35 * temperature_c - (uint32_t)CAL1_T * 35;
  return (voltage_mv * DO_Table[temperature_c] / V_saturation);
#else
  uint16_t V_saturation = (int16_t)((int8_t)temperature_c - CAL2_T) * ((uint16_t)CAL1_V - CAL2_V) / ((uint8_t)CAL1_T - CAL2_T) + CAL2_V;
  return (voltage_mv * DO_Table[temperature_c] / V_saturation);
#endif
}


void cloud_stat(){
  if (ArduinoCloud.connected() == 0) {
    digitalWrite(LED,HIGH);
    delay(1000);
    digitalWrite(LED,LOW);
    wifiLED = true;
    delay(1000);
  } else {
    digitalWrite(LED,HIGH);
    wifiLED = false;
  }
}

void setup() {
  // Initialize serial and wait for port to open:
  Serial.begin(9600);
  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);

  myservo.attach(17);
  pinMode(RELAY_PIN, OUTPUT);
  pinMode(LED,OUTPUT);
  digitalWrite(RELAY_PIN,HIGH);
  delay(1500); 

  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);
  
  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information you’ll get.
     The default is 0 (only errors).
     Maximum is 4
 */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();
}

void loop() {
ArduinoCloud.update();

  //cloud status
  cloud_stat();
  
//temp code
  tempSensor.requestTemperatures();             // send the command to get temperatures
  tempCelsius = tempSensor.getTempCByIndex(0);  // read temperature in Celsius
  tempFahrenheit = tempCelsius * 9 / 5 + 32; // convert Celsius to Fahrenheit

  Serial.print("Temperature: ");
  Serial.print(tempCelsius);    // print the temperature in Celsius
  Serial.print("°C");
  Serial.print("  ~  ");        // separator between Celsius and Fahrenheit
  Serial.print(tempFahrenheit); // print the temperature in Fahrenheit
  Serial.println("°F");
delay(100);  

//ph code 
    for(int i=0;i<10;i++)
{
buffer_arr[i]=analogRead(33);
delay(30);
}
for(int i=0;i<9;i++)
{
for(int j=i+1;j<10;j++)
{
if(buffer_arr[i]>buffer_arr[j])
{
temp=buffer_arr[i];
buffer_arr[i]=buffer_arr[j];
buffer_arr[j]=temp;
}
}
}
avgval=0;
for(int i=2;i<8;i++)
avgval+=buffer_arr[i];
float volt=(float)avgval*5.0/1024/36;
  phValue = -5.70 * volt + calibration_value;
 
Serial.print("pH Val: " );
Serial.println(phValue);
delay(200);

//do code
  Temperaturet = (uint8_t)READ_TEMP;
  ADC_Raw = analogRead(DO_PIN);
  ADC_Voltage = uint32_t(VREF) * ADC_Raw / ADC_RES;

//get DO value in float
  String storedo = String(readDO(ADC_Voltage, Temperaturet));
  float floatdissolved = storedo.toFloat();
  dissolved = floatdissolved/1000.0;
  Serial.print("DO:\t");
  Serial.print(dissolved);
  Serial.println("mg/L");
delay(300);
  temp_change();
  ph_change();
  do_change();
  check_aerator();
  delay(5000);
}

//email functions
bool sendEmailNotification(String emailMessage){
  // Set the SMTP Server Email host, port, account and password
  smtpData.setLogin(smtpServer, smtpServerPort, emailSenderAccount, emailSenderPassword);

  // For library version 1.2.0 and later which STARTTLS protocol was supported,the STARTTLS will be 
  // enabled automatically when port 587 was used, or enable it manually using setSTARTTLS function.
  //smtpData.setSTARTTLS(true);

  // Set the sender name and Email
  smtpData.setSender("ESP32", emailSenderAccount);

  // Set Email priority or importance High, Normal, Low or 1 to 5 (1 is highest)
  smtpData.setPriority("High");

  // Set the subject
  smtpData.setSubject(emailSubject);

  // Set the message with HTML format
  smtpData.setMessage(emailMessage, true);

  // Add recipients
  smtpData.addRecipient(inputMessage);

  smtpData.setSendCallback(sendCallback);

  // Start sending Email, can be set callback function to track the status
  if (!MailClient.sendMail(smtpData)) {
    Serial.println("Error sending Email, " + MailClient.smtpErrorReason());
    return false;
  }
  // Clear all data from Email object to free memory
  smtpData.empty();
  return true;
}


// Callback function to get the Email sending status
void sendCallback(SendStatus msg) {
  // Print the current status
  Serial.println(msg.info());

  // Do something when complete
  if (msg.success()) {
    Serial.println("----------------");
  }
}
//email functions ends here


/*
  Since TempCelsius is READ_WRITE variable, onTempCelsiusChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onTempCelsiusChange()  {

  
  
}


void onTempFahrenheitChange() {
  
}

/*
  Since PhValue is READ_WRITE variable, onPhValueChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onPhValueChange()  {
  
}

/*
  Since Dissolved is READ_WRITE variable, onDissolvedChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onDissolvedChange()  {

}

void onStepperVariable1Change() {
  
}
void onStepperVariable2Change() {
  
}
void onStepperVariable3Change() {
  
}
void onStepperVariable4Change() {
  
}
void onStepperVariable5Change() {
  
}
void onStepperVariable6Change() {
  
}







/*
  Since ServoPushButton is READ_WRITE variable, onServoPushButtonChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onServoPushButtonChange()  {
  if(servoPushButton == 1){
    for (pos = 0; pos <= 90; pos += 1) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    myservo.write(pos);              // tell servo to go to position in variable 'pos'
    delay(15);                       // waits 15ms for the servo to reach the position
  }
  delay(1000);
  for (pos = 90; pos >= 0; pos -= 1) { // goes from 180 degrees to 0 degrees
    myservo.write(pos);              // tell servo to go to position in variable 'pos'
    delay(15);                       // waits 15ms for the servo to reach the position
  }
  }
  else if(servoPushButton == 0){
    myservo.write(0);
  }
}

void temp_change(){
  if(tempCelsius < stepperVariable3 &&!emailSent){
    //email
    String emailMessage = String("Temperature reading is below the minimum input threshold. \nCurrent temperature: ") + 
                          String(tempCelsius) + String(" C") +  String(tempFahrenheit) + String(" F \nInput Threshold: ") + String(stepperVariable3);
    if(sendEmailNotification(emailMessage)) {
        Serial.println(emailMessage);
        emailSent = true;
      }
      else {
        Serial.println("Email failed to send");
      }    
      
  }else if (tempCelsius>stepperVariable4){
    //should be aerator
        temp_aerator = true;
        emailSent = false;
  }else if (tempCelsius > stepperVariable3 && tempCelsius < stepperVariable4){
        temp_aerator = false;
  }
  
}

void ph_change(){
  // Add your code here to act upon PhValue change
  if(phValue < stepperVariable1 && !emailSent1){
    String emailMessage =   String("PH reading is below the minimum input threshold.\nCurrent PH: ") + 
                            String(phValue) + String("\nInput Threshold: ") + String(stepperVariable1);
    if(sendEmailNotification(emailMessage)) {
        Serial.println(emailMessage);
        emailSent1 = true; 
        }
        else {
        Serial.println("Low PH Email failed to send");
      }    
  }
  else if(phValue > stepperVariable2 && emailSent1){
    String emailMessage =   String("PH reading is above the maximum input threshold.\nCurrent PH: ") + 
                            String(phValue) + String("\nInput Threshold: ") + String(stepperVariable2);
    if(sendEmailNotification(emailMessage)) {
        Serial.println(emailMessage);
        emailSent1 = false;
        }
        else {
        Serial.println("High PH Email failed to send");
      }
  }
}

void do_change(){
    // Add your code here to act upon Dissolved change
  if(dissolved < stepperVariable5 ){
  //aerator will turn on
      do_aerator = true;
  }
  else if(dissolved > stepperVariable5 ){
  //email
  //aerator will turn off 
      do_aerator = false;
  }
}

void check_aerator(){
  if(do_aerator == true|| temp_aerator == true){
    digitalWrite(RELAY_PIN, LOW);
  }else if(do_aerator == false && temp_aerator == false){
    digitalWrite(RELAY_PIN, HIGH);
  }
  
}



/*
  Since MessengerUpdates is READ_WRITE variable, onMessengerUpdatesChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onMessengerUpdatesChange()  {
  // Add your code here to act upon MessengerUpdates change
}




